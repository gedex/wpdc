// +build ignore

// mkdeprecatedlist generates deprecatedlist.go, containing list of deprecated
// functions or classes from WordPress and popular plugins, e.g. WooCommerce.
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"net/http"

	"github.com/stephens2424/php/lexer"
	"github.com/stephens2424/php/token"
)

var deprecatedSrc = []string{
	// From core.
	"https://core.trac.wordpress.org/browser/trunk/src/wp-includes/deprecated.php?format=txt",
	"https://core.trac.wordpress.org/browser/trunk/src/wp-admin/includes/deprecated.php?format=txt",
	"https://core.trac.wordpress.org/browser/trunk/src/wp-includes/pluggable-deprecated.php?format=txt",
	"https://core.trac.wordpress.org/browser/trunk/src/wp-includes/ms-deprecated.php?format=txt",
	"https://core.trac.wordpress.org/browser/trunk/src/wp-admin/includes/ms-deprecated.php?format=txt",

	// WooCommerce.
	"https://raw.githubusercontent.com/woothemes/woocommerce/master/includes/wc-deprecated-functions.php",
}

func main() {
	var buf bytes.Buffer
	outf := func(format string, args ...interface{}) {
		fmt.Fprintf(&buf, format, args...)
	}
	outf("// AUTO-GENERATED BY mkdeprecatedlist.go\n\n")
	outf("package wpdc\n\n")
	outf("var deprecated = map[string]string{\n")

	index := make(map[string]bool) // To avoid duplicate key.
	for _, url := range deprecatedSrc {
		src, err := fetchSrc(url)
		if err != nil {
			log.Fatal(err)
		}

		var foc bool
		var classDeclaration bool
		lex := token.Subset(lexer.NewLexer(src), token.Significant)
		for item := lex.Next(); item.Typ != token.EOF; item = lex.Next() {
			switch item.Typ {
			case token.Function:
				foc = true
			case token.Class:
				foc, classDeclaration = true, true
			case token.Identifier:
				if _, ok := index[item.Val]; !ok && foc {
					index[item.Val] = true
					outf("\t%q: %q,\n", item.Val, url)
					foc = false
				}

				if classDeclaration {
					skipInsideClass(lex)
					classDeclaration = false
				}
			default:
				foc = false
			}
		}
	}
	outf("}\n")

	fmtbuf, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	err = ioutil.WriteFile("deprecatedlist.go", fmtbuf, 0666)
	if err != nil {
		log.Fatal(err)
	}
}

func fetchSrc(src string) (out string, err error) {
	resp, err := http.Get(src)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}
	out = string(body)

	return
}

func skipInsideClass(lex token.Stream) {
	var item token.Item

	// Reaching this means current item is class's name, so find until the
	// beginning of class' block and ignore everything inside the block
	// until class' block end.
	for item = lex.Next(); item.Typ != token.BlockBegin; item = lex.Next() {
	}

	unclosed := 0

InClass:
	for {
		item = lex.Next()
		switch item.Typ {
		case token.BlockBegin:
			unclosed += 1
		case token.BlockEnd:
			if unclosed == 0 {
				break InClass
			}
			unclosed -= 1
		}
	}
}
